generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Theme {
  light
  dark
}

model User {
  id                     Int             @id @default(autoincrement())
  email                  String          @unique
  username               String          @unique @db.VarChar(16)
  password               String
  firstName              String
  lastName               String
  birthday               DateTime
  currency               String
  theme                  Theme           @default(light)
  mobileNumber           String?
  totalMoneySavedToDate  Float           @default(0)
  emailVerified          Boolean         @default(false)
  loggedIn               Boolean         @default(false)
  signedVerificationCode String?
  createdAt              DateTime        @default(now())
  updatedAt              DateTime        @updatedAt
  // One To One
  overview               Overview?
  // Has Many
  logbooks               Logbook[]
  logbookReviews         LogbookReview[]
}

enum Category {
  need
  want
}

model Purchase {
  id                            Int            @id @default(autoincrement())
  placement                     Int
  cost                          Float
  category                      Category?
  description                   String
  createdAt                     DateTime       @default(now())
  updatedAt                     DateTime       @updatedAt
  // Belongs To
  overviewRecurringPurchases    Overview?      @relation(name: "RecurringPurchases", fields: [overviewRecurringPurchasesId], references: [id], onDelete: Cascade)
  overviewRecurringPurchasesId  Int?
  overviewIncomingPurchases     Overview?      @relation(name: "IncomingPurchases", fields: [overviewIncomingPurchasesId], references: [id], onDelete: Cascade)
  overviewIncomingPurchasesId   Int?
  // 
  logbookGroup                  LogbookGroup?  @relation(fields: [logbookGroupId], references: [id])
  logbookGroupId                Int?
  // 
  logbookReviewNeeds            LogbookReview? @relation(name: "ReviewNeeds", fields: [logbookReviewNeedsId], references: [id])
  logbookReviewNeedsId          Int?
  logbookReviewPlannedWants     LogbookReview? @relation(name: "ReviewPlannedWants", fields: [logbookReviewPlannedWantsId], references: [id])
  logbookReviewPlannedWantsId   Int?
  logbookReviewImpulsiveWants   LogbookReview? @relation(name: "ReviewImpulsiveWants", fields: [logbookReviewImpulsiveWantsId], references: [id])
  logbookReviewImpulsiveWantsId Int?
  logbookReviewRegrets          LogbookReview? @relation(name: "ReviewRegrets", fields: [logbookReviewRegretsId], references: [id])
  logbookReviewRegretsId        Int?
}

model Overview {
  id                 Int        @id @default(autoincrement())
  income             Float?
  savings            Float      @default(0)
  createdAt          DateTime   @default(now())
  updatedAt          DateTime   @updatedAt
  // One To One
  owner              User       @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId            Int        @unique
  // Has Many
  recurringPurchases Purchase[] @relation(name: "RecurringPurchases")
  incomingPurchases  Purchase[] @relation(name: "IncomingPurchases")
}

// Automatically created at the beginning of a new month.
// `name` field default to month and year in which the logbook was created (e.g. "Jan. 2023").
// `name` field MAY be edited later down the line for potentially better UX.
model Logbook {
  id        Int            @id @default(autoincrement())
  name      String
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  // Has Many
  groups    LogbookGroup[]
  // Belongs to
  owner     User           @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId   Int
}

model LogbookGroup {
  id        Int        @id @default(autoincrement())
  date      DateTime
  totalCost Float      @default(0)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  // Has Many
  purchases Purchase[]
  // Belongs To
  logbook   Logbook    @relation(fields: [logbookId], references: [id], onDelete: Cascade)
  logbookId Int
}

model LogbookReview {
  id             Int        @id @default(autoincrement())
  reflection     String?    @default("")
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt
  // Has Many
  needs          Purchase[] @relation(name: "ReviewNeeds")
  plannedWants   Purchase[] @relation(name: "ReviewPlannedWants")
  impulsiveWants Purchase[] @relation(name: "ReviewImpulsiveWants")
  regrets        Purchase[] @relation(name: "ReviewRegrets")
  // Belongs to
  owner          User       @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId        Int
}
