generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Theme {
  light
  dark
}

model User {
  id                     Int             @id @default(autoincrement())
  email                  String          @unique
  username               String          @unique @db.VarChar(16)
  password               String
  firstName              String
  lastName               String
  birthday               DateTime
  currency               String
  theme                  Theme           @default(light)
  mobileNumber           String?
  totalMoneySavedToDate  Float           @default(0)
  emailVerified          Boolean         @default(false)
  loggedIn               Boolean         @default(false)
  signedVerificationCode String?
  createdAt              DateTime        @default(now())
  updatedAt              DateTime        @updatedAt
  // One To One
  overview               Overview?
  // Has Many
  logbooks               Logbook[]
  logbookReviews         LogbookReview[]
}

enum Category {
  need
  want
}

model Purchase {
  id                            Int            @id @default(autoincrement())
  placement                     Int
  cost                          Float
  category                      Category?
  description                   String
  createdAt                     DateTime       @default(now())
  updatedAt                     DateTime       @updatedAt
  // Belongs To
  overviewRecurringPurchases    Overview?      @relation(name: "OverviewRecurringPurchases", fields: [overviewRecurringPurchasesId], references: [id], onDelete: Cascade)
  overviewRecurringPurchasesId  Int?
  overviewIncomingPurchases     Overview?      @relation(name: "OverviewIncomingPurchases", fields: [overviewIncomingPurchasesId], references: [id], onDelete: Cascade)
  overviewIncomingPurchasesId   Int?
  // 
  logbookDay                    LogbookDay?    @relation(fields: [logbookDayId], references: [id])
  logbookDayId                  Int?
  // 
  logbookReviewNeeds            LogbookReview? @relation(name: "LogbookReviewNeeds", fields: [logbookReviewNeedsId], references: [id])
  logbookReviewNeedsId          Int?
  logbookReviewPlannedWants     LogbookReview? @relation(name: "LogbookReviewPlannedWants", fields: [logbookReviewPlannedWantsId], references: [id])
  logbookReviewPlannedWantsId   Int?
  logbookReviewImpulsiveWants   LogbookReview? @relation(name: "LogbookReviewImpulsiveWants", fields: [logbookReviewImpulsiveWantsId], references: [id])
  logbookReviewImpulsiveWantsId Int?
  logbookReviewRegrets          LogbookReview? @relation(name: "LogbookReviewRegrets", fields: [logbookReviewRegretsId], references: [id])
  logbookReviewRegretsId        Int?
}

model Overview {
  id                 Int        @id @default(autoincrement())
  income             Float
  savings            Float      @default(0)
  earnedBudget       Float      @default(0)
  createdAt          DateTime   @default(now())
  updatedAt          DateTime   @updatedAt
  // One To One
  owner              User       @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId            Int        @unique
  // Has Many
  recurringPurchases Purchase[] @relation(name: "OverviewRecurringPurchases")
  incomingPurchases  Purchase[] @relation(name: "OverviewIncomingPurchases")
}

// Automatically created at the beginning of a new month.
// `name` field default to month and year in which the logbook was created (e.g. "Jan. 2023").
// `name` field MAY be edited later down the line for potentially better UX.
model Logbook {
  id        Int          @id @default(autoincrement())
  name      String
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  // Has Many
  days      LogbookDay[]
  // Belongs to
  owner     User         @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId   Int
}

model LogbookDay {
  id        Int        @id @default(autoincrement())
  date      DateTime
  totalCost Float      @default(0)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  // Has Many
  purchases Purchase[]
  // Belongs To
  logbook   Logbook    @relation(fields: [logbookId], references: [id], onDelete: Cascade)
  logbookId Int
}

model LogbookReview {
  id             Int        @id @default(autoincrement())
  reflection     String?    @default("")
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt
  // Has Many
  needs          Purchase[] @relation(name: "LogbookReviewNeeds")
  plannedWants   Purchase[] @relation(name: "LogbookReviewPlannedWants")
  impulsiveWants Purchase[] @relation(name: "LogbookReviewImpulsiveWants")
  regrets        Purchase[] @relation(name: "LogbookReviewRegrets")
  // Belongs to
  owner          User       @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId        Int
}
